<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>src/AudioAnimation.js - CloudKid Audio API</title>
    <link rel="stylesheet" href="http://yui.yahooapis.com/3.9.1/build/cssgrids/cssgrids-min.css">
    <link rel="stylesheet" href="../assets/vendor/prettify/prettify-min.css">
    <link rel="stylesheet" href="../assets/css/main.css" id="site_styles">
    <link rel="shortcut icon" type="image/png" href="../assets/favicon.png">
    <script src="http://yui.yahooapis.com/combo?3.9.1/build/yui/yui-min.js"></script>
</head>
<body class="yui3-skin-sam">

<div id="doc">
    <div id="hd" class="yui3-g header">
        <div class="yui3-u-3-4">
            
                <h1><img src="../cloudkid.png" title="CloudKid Audio API"></h1>
            
        </div>
        <div class="yui3-u-1-4 version">
            <em>API Docs for: 1.0.0</em>
        </div>
    </div>
    <div id="bd" class="yui3-g">

        <div class="yui3-u-1-4">
            <div id="docs-sidebar" class="sidebar apidocs">
                <div id="api-list">
    <h2 class="off-left">APIs</h2>
    <div id="api-tabview" class="tabview">
        <ul class="tabs">
            <li><a href="#api-classes">Classes</a></li>
            <li><a href="#api-modules">Modules</a></li>
        </ul>

        <div id="api-tabview-filter">
            <input type="search" id="api-filter" placeholder="Type to filter APIs">
        </div>

        <div id="api-tabview-panel">
            <ul id="api-classes" class="apis classes">
            
                <li><a href="../classes/cloudkid.Audio.html">cloudkid.Audio</a></li>
            
                <li><a href="../classes/cloudkid.AudioAnimation.html">cloudkid.AudioAnimation</a></li>
            
            </ul>

            <ul id="api-modules" class="apis modules">
            
            </ul>
        </div>
    </div>
</div>

            </div>
        </div>
        <div class="yui3-u-3-4">
                <div id="api-options">
        Show:
        <label for="api-show-inherited">
            <input type="checkbox" id="api-show-inherited" checked>
            Inherited
        </label>

        <label for="api-show-protected">
            <input type="checkbox" id="api-show-protected">
            Protected
        </label>

        <label for="api-show-private">
            <input type="checkbox" id="api-show-private">
            Private
        </label>
        <label for="api-show-deprecated">
            <input type="checkbox" id="api-show-deprecated">
            Deprecated
        </label>

    </div>


            <div class="apidocs">
                <div id="docs-main">
                    <div class="content">
                        <h1 class="file-heading">File: src/AudioAnimation.js</h1>

<div class="file">
    <pre class="code prettyprint linenums">
(function(undefined){
	
	&quot;use strict&quot;;
	
	// Imports
	var Audio = cloudkid.Audio,
		OS = cloudkid.OS,
		Captions = cloudkid.Captions,
		Animator = cloudkid.Animator,
		PageVisibility = cloudkid.PageVisibility;
	
	/**
	*   AudioAnimation Handles playback of a single MovieClip in sync with a sound managed by cloudkid.Audio
	*	@class cloudkid.AudioAnimation
	*   @constructor
	*   @param {createjs.MovieClip} movieClip the animation to sync with sound
	*	@param {String} soundAlias the name of the sound to play with MovieClip
	*	@param {String*} frameLabel the alias of the animation sequence to sync with sound 
	*		Leave blank (or null) to play whole movieClip
	*	@param {Number*} numLoops the number of times to play the synced animation when play() is called. 
	*		value of 0 loops forever. Leave blank to play 1 time (or set as 1)
	*	@param {Number*} soundStartFrame frame number on which synced sound starts 
	*       (EaselJS frame numbers start at &quot;0&quot; where flash is &quot;1&quot;)
	*/
	var AudioAnimation = function(movieClip, soundAlias, frameLabel, numLoops, soundStartFrame)
	{
		this.initialize(movieClip, soundAlias, frameLabel, numLoops, soundStartFrame);
	},
	
	// Reference to the prototype 
	p = AudioAnimation.prototype,
	
	/** 
	* Referece to current instance of Audio 
	* @private
	* @property {cloudkid.Audio}
	*/
	_audio = null,
	
	/** 
	* The current number of sound animations created 
	* @private
	* @property {int}
	* @default 0
	*/
	_audioAnims = 0;

	
	/** 
	* The MovieClip to sync with sound 
	* @private
	* @property {createjs.MovieClip} _clip
	*/
	p._clip = null;
	
	/** 
	* The page visibility detector 
	* @private
	* @property {cloudkid.PageVisibility} _visibility
	*/
	p._visibility = null;
	
	/** 
	* Name of the sound tp sync MovieClip to
	* @private
	* @property {String} _audioAlias
	*/
	p._audioAlias = null;
	
	/** 
	* Label of animation sequence to sync 
	* @private
	* @property {String} _frameLabel
	*/
	p._frameLabel = null;
	
	/** 
	* Numeric first frame of MovieClip in this animation sequence 
	* @private
	* @property {int} _animStartFrame
	*/
	p._animStartFrame = 0;
	
	/**
	* Numeric last frame of MovieClip in this animation sequence 
	* @private
	* @property {int} _animEndFrame
	*/
	p._animEndFrame = null;
	
	/** 
	* Number of frames in sequence 
	* @private
	* @property {int} _animDuration
	*/
	p._animDuration = 0;
	
	/** 
	* TweenJS Timeline Frame to start sound 
	* @private
	* @property {int} _audioStartFrame
	*/
	p._audioStartFrame = 0;
	
	/** 
	* Length of sound in frames 
	* @private
	* @property {int} _audioDuration
	*/
	p._audioDuration = 0;
	
	/** 
	* Has the sound started playing yet? 
	* @private
	* @property {Bool} _audioStarted
	* @default false
	*/
	p._audioStarted = false;
	
	/** 
	* Target frames per second of MovieClip 
	* @private
	* @property {int} _animationFPS
	* @default 24
	*/
	p._animationFPS = 24;
	
	/** 
	* Number of times to play through. 0 means infinite 
	* @private
	* @property {int} _totalLoops
	* @default 1
	*/
	p._totalLoops = 1;
	
	/** 
	* Keeps track of number of times played through 
	* @private
	* @property {int} _currentLoop
	* @default 0
	*/
	p._currentLoop = 0;
	
	/** 
	* Previous percentage progress value received from Audio 
	* @private
	* @property {Number} _lastProgress
	* @default 0
	*/
	p._lastProgress = 0;
	
	/** 
	* Has this animation been paused by the pause() function? 
	* @public
	* @property {Bool} paused
	* @default false
	* @readOnly
	*/
	p.paused = false;
	
	/** 
	* Reference to the AnimatorTimeline of current animation sequence 
	* @private
	* @property {cloudkid.AnimatorTimeline} _animation
	*/
	p._animation = null;
	
	/** 
	* Callback when we&#x27;re done playing 
	* @private
	* @property {Function} _playCompleteCallback
	*/
	p._playCompleteCallback = null;
	
	/** 
	* Boolean to check if the sound is finished 
	* @private
	* @property {Bool} _audioDone
	*/
	p._audioDone = false;
	
	/** 
	* Boolean to check if the animation is done 
	* @private
	* @property {Bool} _animDone
	*/
	p._animDone = false;
	
	/** 
	* Fudge Factor – how many frames out of sync can we be before we make corrections
	* @private
	* @property {int} _syncDiff
	* @default 2
	*/
	p._syncDiff = 2;
	
	/** 
	* If this should also control some captions as well. 
	* @private
	* @property {Bool} _handleCaptions
	* @default false
	*/
	p._handleCaptions = false;
	
	/** 
	* A function to call when handling captions. 
	* @private
	* @property {Function} _captionUpdate
	*/
	p._captionUpdate = null;
			
	/**
	*  Constructor function for the AudioAnimation class
	*  @constructor
	*  @method initialize
	*  @param {createjs.MovieClip} movieClip Reference to the movie clip
	*  @param {String} soundAlias The alias to the sound to play
	*  @param {String*} frameLabel The frame label to play using Animator
	*  @param {Number*} numLoops The number of loops, defaults to 1, 0 is infinite
	*  @param {Number*} soundStartFrame Specify a start sound frame, default to sound start
	*/
	p.initialize = function(movieClip, soundAlias, frameLabel, numLoops, soundStartFrame)
	{
		this._clip = movieClip;
		this._audioAlias = soundAlias;
		this._frameLabel = (frameLabel === undefined) ? null : frameLabel;
		this._totalLoops = (numLoops === undefined) ? 1 : numLoops;
		
		if(this._frameLabel !== null)
		{
			this._animStartFrame = this._clip.timeline.resolve(this._frameLabel);
			if(this._totalLoops == 1)
			{
				this._animEndFrame = this._clip.timeline.resolve(this._frameLabel + &quot;_stop&quot;);
				if(this._animEndFrame === undefined)
				{
					this._animEndFrame = this._clip.timeline.resolve(this._frameLabel + &quot;_loop&quot;);
				}
			}
			else
			{
				this._animEndFrame = this._clip.timeline.resolve(this._frameLabel + &quot;_loop&quot;);
				if(this._animEndFrame === undefined)
				{
					this._animEndFrame = this._clip.timeline.resolve(this._frameLabel + &quot;_stop&quot;);
				}
			}
		}
		else
		{
			this._animEndFrame = this._clip.timeline.duration - 1;
		}
		
		this._audioStartFrame = (soundStartFrame === undefined) ? this._animStartFrame : soundStartFrame;
		this._animDuration = this._animEndFrame - this._animStartFrame;
		
		if(_audio === null)
			_audio = Audio.instance;
		
		_audioAnims++;
		
		// Get the number of frames in the animation
		this._animationFPS = OS.instance.fps;
		this._audioDuration = Math.round(_audio.getLength(this._audioAlias) * this._animationFPS);
		
		if(this._audioDuration != this._animDuration &amp;&amp; _audio.isLooping(this._audioAlias))
		{
			Debug.warn(&quot;The sound &#x27;&quot; + this._audioAlias + &quot;&#x27; and animation &#x27;&quot; + this._frameLabel + &quot;&#x27; aren&#x27;t the same length (sound: &quot; + this._audioDuration+ &quot;, animation: &quot; + this._animDuration + &quot;)&quot;);
		}
		
		var self = this, autoPaused = -1;
		this._visibility = new PageVisibility(
			function()
			{
				if (autoPaused === 0) 
				{
					if (self._animation) self._animation.setPaused(false);
				}
				autoPaused = -1;
			},
			function() 
			{		
				if (autoPaused === -1)
				{
					// save the current status of the paused state
					autoPaused = self.paused ? 1 : 0;
				}
				if (self._animation) self._animation.setPaused(true);
			}
		);
	};
	
	/**
	*   Play Animation and Audio from beginning
	*   @method play
	*   @public
	*   @param {function} The optional callback when we&#x27;re done playing, non-looping sound only!
	*/
	p.play = function(callback)
	{
		// Immediately stop any sound that&#x27;s playing
		_audio.stop();
		
		this._playCompleteCallback = (callback !== undefined) ? callback : null;
		this._currentLoop = 1;
		this._handleCaptions = Captions &amp;&amp; Captions.instance &amp;&amp; Captions.instance.hasCaption(this._audioAlias);
		this._captionUpdate = this._handleCaptions ? Captions.instance.run(this._audioAlias) : null;
		this._startPlayback();
	};
	
	/** 
	* Play AudioAnimation after data is ready. Also used for looping
	* @method _startPlayback
	* @private
	*/
	p._startPlayback = function()
	{
		this._animation = null;
		this._lastProgress = 0;
		this._audioDone = false;
		this._animDone = false;
		this.paused = false;
		
		// is sound set to start within 2 frames of animation?
		if(this._audioStartFrame &lt;= this._animStartFrame + this._syncDiff)
		{
			this._audioStarted = true;
			this._animation = Animator.play(
				this._clip,	
				this._frameLabel, 
				this._animationFinished.bind(this), 
				null, true
			);
			_audio.play(
				this._audioAlias, 
				this._audioFinished.bind(this),
				this._update.bind(this)
			);
		}
		else
		{
			if (DEBUG)
			{
				Debug.log(&quot;Delay starting sound because of frame offset&quot;);
			}
			
			this._clip.timeline.addEventListener(&quot;change&quot;, this._onFrameUpdate.bind(this));
			_audio.prepare(this._audioAlias);
			this._audioStarted = false;
			this._animation = Animator.play(
				this._clip,	
				this._frameLabel, 
				this._animationFinished.bind(this), 
				null, true
			);
		}
	};
	
	/** 
	*  We recieved loop callback from sound or the sound is over
	*  @private
	*  @method _audioFinished
	*/
	p._audioFinished = function()
	{
		if(!this._animDone &amp;&amp; this._animation &amp;&amp; this._animation.getPaused())
		{
			this._animation.setPaused(false);
		}
		this._audioDone = true;
		this._doneCheck();
	};
	
	/**
	*  Callback when the animation is finished
	*  @private
	*  @method _animationFinished
	*/
	p._animationFinished = function()
	{
		if(this._animation)
			this._animation.onComplete = null;
			
		this._animDone = true;
		this._doneCheck();
	};
	
	/** 
	*  Pause Animation and Audio at current position to be resumed later
	*  @method pause
	*  @public
	*/
	p.pause = function()
	{
		if (!this.paused)
		{
			this.paused = true;
			_audio.pause();
			if (this._animation) 
				this._animation.setPaused(true);
		}
	};
	
	/** 
	*  Resume playback of Audio and Animation from paused position 
	*  @method resume
	*  @public
	*/
	p.resume = function()
	{
		if (this.paused)
		{
			this.paused = false;
			_audio.resume();
			if (this._animation) 
				this._animation.setPaused(false);
		}
	};
	
	/** 
	*  Stop playing animation and sound, and forget about current position 
	*  @method stop
	*  @public
	*  @param {Bool} If we should do the callback (for instance, when skipping an animation)
	*/
	p.stop = function(doCallback)
	{
		_audio.stop();
		Animator.stop(this._clip);
		this.paused = true;
		this._animation = null;
		
		doCallback = (doCallback === undefined) ? false : doCallback;
		
		// Check to see if we should do the callback
		if(this._playCompleteCallback &amp;&amp; doCallback) 
		{
			this._playCompleteCallback();
		}
		this._playCompleteCallback = null;	
	};
	
	/**
	*  Check to see if we should do the finishing callback
	*  @private
	*  @method _doneCheck
	*/
	p._doneCheck = function()
	{		
		// Don&#x27;t do the callback if the animation or sound aren&#x27;t finished
		// this make it so the animation or the sound can be longer
		if (!this._animDone || !this._audioDone) return;
		
		var infinite = this._totalLoops === 0;
		
		// Check to see if we should keep looping
		if (infinite || this._totalLoops &gt; 1)
		{
			if(infinite || this._currentLoop &lt; this._totalLoops)
			{
				Animator.stop(this._clip);
				this._currentLoop++;
				this._startPlayback();
			}
			else
			{
				this.stop(true);
			}
		}
		else
		{
			this.stop(true);
		}
	};
	
	/** 
	*   We recieved a progress event from the sound. 
	*   Let&#x27;s make sure the animation isn&#x27;t too far ahead or behind
	*   @method _update
	*   @private
	*   @param {Number} The current percentage
	*/
	p._update = function(progress)
	{
		if (this.paused) return;
		
		if(this._captionUpdate)
			this._captionUpdate(progress);
		
		// Audio is playing
		if(progress &gt; this._lastProgress)
		{	
			if(progress == 1 &amp;&amp; this._lastProgress === 0) return;
			// Save the last percent
			this._lastProgress = progress;
			
			// If the animation is done, ignore this
			if (this._animDone) return;
			
			// Audio position in frames
			var soundPos = parseInt(this._audioStartFrame, 10) + Math.round(this._audioDuration * this._lastProgress);
			
			// Clip position in frames
			var clipPos = this._clip.timeline.position;
			
			//if (DEBUG)
			//{
			//	Debug.log(&quot;Audio Position: &quot; + soundPos + &quot; start: &quot; + this._audioStartFrame + &quot; duration: &quot; + this._audioDuration + &quot; lastProgress: &quot; + this._lastProgress + &quot; clipPos: &quot; + clipPos + &quot; animStart: &quot; + this._animStartFrame + &quot; animEnd: &quot; + this._animEndFrame);
			//}
			
			// The animation is behind, catch up
			if(soundPos &gt; clipPos)
			{
				// Unpause the sound if it&#x27;s paused
				if(this._animation.getPaused())
				{
					this._animation.setPaused(false);
				}
				
				if (soundPos &gt; this._animEndFrame)
				{
					this._animationFinished();
				}
				else
				{
					this._clip.gotoAndPlay(soundPos);
				}
				
			}
			//Whoa, Nelly! – Slow down, animation
			else if(soundPos + this._syncDiff &lt; clipPos &amp;&amp; this._lastProgress != 1)
			{
				this._animation.setPaused(true);
			}
		}
	};
	
	/** 
	* Used to check if it&#x27;s time to start a delayed sound 
	* @private
	* @method _onFrameUpdate
	*/
	p._onFrameUpdate = function()
	{
		if (DEBUG)
		{
			Debug.log(&quot;Anim Position: &quot; + this._clip.timeline.position);
		}
		if(!this._audioStarted &amp;&amp; this._clip.timeline.position &gt;= this._audioStartFrame)
		{
			this._audioStarted = true;
			_audio.play(
				this._audioAlias, 
				this._audioFinished.bind(this),
				this._update.bind(this)
			);
			this._clip.timeline.removeAllEventListeners();
		}
	};
	
	/**  
	*  Clear data and remove all references, don&#x27;t use object after this
	*  @public
	*  @method destroy
	*/
	p.destroy = function()
	{
		_audioAnims--;
		
		// If there are no more animation remove reference to sound class
		if(_audioAnims === 0) _audio = null;
		
		if (this._visibility)
		{
			this._visibility.destroy();
		}
		
		this._visibility =
		this._clip =
		this._audioAlias =
		this._totalLoops =
		this._frameLabel =
		this._animStartFrame =
		this._animEndFrame =
		this._animDuration =
		this._totalLoops =
		this._currentLoop =
		this._lastProgress =
		this._animation = null;
	};
	
	// Assign to the cloudkid namespace
	namespace(&#x27;cloudkid&#x27;).AudioAnimation = AudioAnimation;
}());
    </pre>
</div>

                    </div>
                </div>
            </div>
        </div>
    </div>
</div>
<script src="../assets/vendor/prettify/prettify-min.js"></script>
<script>prettyPrint();</script>
<script src="../assets/js/yui-prettify.js"></script>
<script src="../assets/../api.js"></script>
<script src="../assets/js/api-filter.js"></script>
<script src="../assets/js/api-list.js"></script>
<script src="../assets/js/api-search.js"></script>
<script src="../assets/js/apidocs.js"></script>
</body>
</html>
